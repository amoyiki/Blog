---
title: '[转]Java集合小抄'
date: 2017-01-18 15:18:39
categories: "Java"
tags:
- 学习
---

## List ##
### ArrayList ###
- 以数组实现，节约空间。但是数组容量限制，超出限制会增加50%容量，用System.arraycopy()复制到新的数组。因此最好能给出数组大小的预估值。
- 默认第一次大小为10。
<!-- more -->
- 按下标访问元素，get(下标获取元素)、set(替换下标元素)的性能很高，
是数组的基本优势。
- 按下标插入元素，删除元素，add(i,e)、remove(i)、remove(e),则会用到System.arraycopy()来复制移动受影响的元素,性能会变差。
- 越是前面的元素，修改的时候移动的元素越多。用add(e)在尾部添加元素、删除最后一个元素不会影响性能。
### LinkedList ###
- 以双向链表实现，链表无容量限制，但是双向链表本身使用了更多空间，每插入一个元素都要构造一个额外的Node对象，也需要额外的指针操作。
- 按数组下标访问元素，get(i)、set(i,e),需要移动到指定Node节点(i>节点个数时从尾部移动到头部)
- 插入、删除元素时修改前后节点指针即可
- 只有在两头add()、addFirst()、addLast()、removeFirst()、removeLast()才能省掉指针的移动。

## Map ##
### HashMap ###
- 以Enty[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可以的到数组的下标
- 插入元素时，如果两条Key落在同一个桶，称之为哈希冲突或者碰撞
- 哈希冲突JDK8之前是用的是链表法，用Entry用一个next属性实现多个Entry以单向链表的形式存放。然后遍历链表中的所有元素，逐一比较Key值
- 在JDK8后，新增链表的阈值为8，链表的元素数量超过阈值时改用红黑树来存储，提高查找速度。
- 当Entry数量达到数组的75%，数组成倍扩容，重新分配原来的Entry，扩容成本不低。
### LinkedHashMap ###
- 扩展HashMap，每个Entry增加双向链表，非常占内存的数据结构
### ConcurrentSkipListMap ###
- JDK6新增并发优化的SortedMap，以SkipList结构实现，支持CAS无锁算法。



